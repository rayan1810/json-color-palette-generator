{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { useRef as $dgwbL$useRef, useEffect as $dgwbL$useEffect, useMemo as $dgwbL$useMemo } from \"react\";\nimport { getFocusableTreeWalker as $dgwbL$getFocusableTreeWalker, focusSafely as $dgwbL$focusSafely } from \"@react-aria/focus\";\nimport { focusWithoutScrolling as $dgwbL$focusWithoutScrolling, useEvent as $dgwbL$useEvent, scrollIntoView as $dgwbL$scrollIntoView, mergeProps as $dgwbL$mergeProps, isAppleDevice as $dgwbL$isAppleDevice, isMac as $dgwbL$isMac } from \"@react-aria/utils\";\nimport { useLocale as $dgwbL$useLocale, useCollator as $dgwbL$useCollator } from \"@react-aria/i18n\";\nimport { usePress as $dgwbL$usePress, useLongPress as $dgwbL$useLongPress } from \"@react-aria/interactions\";\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nvar $52ac987c016884e9$exports = {};\n$parcel$export($52ac987c016884e9$exports, \"useSelectableCollection\", function () {\n  return $52ac987c016884e9$export$d6daf82dcd84e87c;\n});\n\nfunction $c636d3b6065ca9f6$export$d3e3bd3e26688c04(e) {\n  return $dgwbL$isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nfunction $c636d3b6065ca9f6$export$16792effe837dba3(e) {\n  if ($dgwbL$isMac()) return e.metaKey;\n  return e.ctrlKey;\n}\n\nvar $a6f03d1cafa48b51$exports = {};\n$parcel$export($a6f03d1cafa48b51$exports, \"useTypeSelect\", function () {\n  return $a6f03d1cafa48b51$export$e32c88dfddc6e1d8;\n});\n\nfunction $a6f03d1cafa48b51$export$e32c88dfddc6e1d8(options) {\n  var keyboardDelegate = options.keyboardDelegate,\n      selectionManager = options.selectionManager,\n      onTypeSelect = options.onTypeSelect;\n  var state = $dgwbL$useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  var onKeyDown = function onKeyDown(e) {\n    var character = $a6f03d1cafa48b51$var$getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) return;\n\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) e.stopPropagation();\n    }\n\n    state.search += character;\n    var key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n    if (key == null) key = keyboardDelegate.getKeyForSearch(state.search);\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) onTypeSelect(key);\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function () {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction $a6f03d1cafa48b51$var$getStringForKey(key) {\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) return key;\n  return '';\n}\n\nfunction $52ac987c016884e9$export$d6daf82dcd84e87c(options) {\n  var manager = options.selectionManager,\n      delegate = options.keyboardDelegate,\n      ref = options.ref,\n      _options$autoFocus = options.autoFocus,\n      autoFocus = _options$autoFocus === void 0 ? false : _options$autoFocus,\n      _options$shouldFocusW = options.shouldFocusWrap,\n      shouldFocusWrap = _options$shouldFocusW === void 0 ? false : _options$shouldFocusW,\n      _options$disallowEmpt = options.disallowEmptySelection,\n      disallowEmptySelection = _options$disallowEmpt === void 0 ? false : _options$disallowEmpt,\n      _options$disallowSele = options.disallowSelectAll,\n      disallowSelectAll = _options$disallowSele === void 0 ? false : _options$disallowSele,\n      _options$selectOnFocu = options.selectOnFocus,\n      selectOnFocus = _options$selectOnFocu === void 0 ? manager.selectionBehavior === 'replace' : _options$selectOnFocu,\n      _options$disallowType = options.disallowTypeAhead,\n      disallowTypeAhead = _options$disallowType === void 0 ? false : _options$disallowType,\n      shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n      _options$allowsTabNav = options.allowsTabNavigation,\n      allowsTabNavigation = _options$allowsTabNav === void 0 ? false : _options$allowsTabNav,\n      isVirtualized = options.isVirtualized,\n      _options$scrollRef = options.scrollRef,\n      scrollRef = _options$scrollRef === void 0 ? ref : _options$scrollRef;\n\n  var _$dgwbL$useLocale = $dgwbL$useLocale(),\n      direction = _$dgwbL$useLocale.direction;\n\n  var onKeyDown = function onKeyDown(e) {\n    if (e.altKey && e.key === 'Tab') e.preventDefault();\n    if (!ref.current.contains(e.target)) return;\n\n    var navigateToKey = function navigateToKey(key, childFocus) {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n        if (e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(key);else if (selectOnFocus && !$c636d3b6065ca9f6$export$d3e3bd3e26688c04(e)) manager.replaceSelection(key);\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown':\n        if (delegate.getKeyBelow) {\n          var ref4, ref1;\n          e.preventDefault();\n          var nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (ref4 = delegate.getFirstKey) === null || ref4 === void 0 ? void 0 : ref4.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (ref1 = delegate.getFirstKey) === null || ref1 === void 0 ? void 0 : ref1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n\n        break;\n\n      case 'ArrowUp':\n        if (delegate.getKeyAbove) {\n          var ref2, ref3;\n          e.preventDefault();\n\n          var _nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (ref2 = delegate.getLastKey) === null || ref2 === void 0 ? void 0 : ref2.call(delegate);\n\n          if (_nextKey == null && shouldFocusWrap) _nextKey = (ref3 = delegate.getLastKey) === null || ref3 === void 0 ? void 0 : ref3.call(delegate, manager.focusedKey);\n          navigateToKey(_nextKey);\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n\n          var _nextKey2 = delegate.getKeyLeftOf(manager.focusedKey);\n\n          navigateToKey(_nextKey2, direction === 'rtl' ? 'first' : 'last');\n        }\n\n        break;\n\n      case 'ArrowRight':\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n\n          var _nextKey3 = delegate.getKeyRightOf(manager.focusedKey);\n\n          navigateToKey(_nextKey3, direction === 'rtl' ? 'last' : 'first');\n        }\n\n        break;\n\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          var firstKey = delegate.getFirstKey(manager.focusedKey, $c636d3b6065ca9f6$export$16792effe837dba3(e));\n          manager.setFocusedKey(firstKey);\n          if ($c636d3b6065ca9f6$export$16792effe837dba3(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n        }\n\n        break;\n\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          var lastKey = delegate.getLastKey(manager.focusedKey, $c636d3b6065ca9f6$export$16792effe837dba3(e));\n          manager.setFocusedKey(lastKey);\n          if ($c636d3b6065ca9f6$export$16792effe837dba3(e) && e.shiftKey && manager.selectionMode === 'multiple') manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n        }\n\n        break;\n\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n\n          var _nextKey4 = delegate.getKeyPageBelow(manager.focusedKey);\n\n          navigateToKey(_nextKey4);\n        }\n\n        break;\n\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n\n          var _nextKey5 = delegate.getKeyPageAbove(manager.focusedKey);\n\n          navigateToKey(_nextKey5);\n        }\n\n        break;\n\n      case 'a':\n        if ($c636d3b6065ca9f6$export$16792effe837dba3(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n\n        break;\n\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) manager.clearSelection();\n        break;\n\n      case 'Tab':\n        if (!allowsTabNavigation) {\n          if (e.shiftKey) ref.current.focus();else {\n            var walker = $dgwbL$getFocusableTreeWalker(ref.current, {\n              tabbable: true\n            });\n            var next;\n            var last;\n\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) $dgwbL$focusWithoutScrolling(next);\n          }\n          break;\n        }\n\n    }\n  };\n\n  var scrollPos = $dgwbL$useRef({\n    top: 0,\n    left: 0\n  });\n  $dgwbL$useEvent(scrollRef, 'scroll', isVirtualized ? null : function () {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  var onFocus = function onFocus(e) {\n    if (manager.isFocused) {\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    }\n\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      var navigateToFirstKey = function navigateToFirstKey(key) {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) manager.replaceSelection(key);\n        }\n      };\n\n      var relatedTarget = e.relatedTarget;\n\n      var _lastSelectedKey, _firstSelectedKey;\n\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_lastSelectedKey = manager.lastSelectedKey) !== null && _lastSelectedKey !== void 0 ? _lastSelectedKey : delegate.getLastKey());else navigateToFirstKey((_firstSelectedKey = manager.firstSelectedKey) !== null && _firstSelectedKey !== void 0 ? _firstSelectedKey : delegate.getFirstKey());\n    } else if (!isVirtualized) {\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n      var element = scrollRef.current.querySelector(\"[data-key=\\\"\" + manager.focusedKey + \"\\\"]\");\n\n      if (element) {\n        $dgwbL$focusWithoutScrolling(element);\n        $dgwbL$scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  var onBlur = function onBlur(e) {\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n\n  var autoFocusRef = $dgwbL$useRef(autoFocus);\n  $dgwbL$useEffect(function () {\n    if (autoFocusRef.current) {\n      var focusedKey = null;\n      if (autoFocus === 'first') focusedKey = delegate.getFirstKey();\n      if (autoFocus === 'last') focusedKey = delegate.getLastKey();\n      var selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) focusedKey = selectedKeys.values().next().value;\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n      if (focusedKey == null && !shouldUseVirtualFocus) $dgwbL$focusSafely(ref.current);\n    }\n\n    autoFocusRef.current = false;\n  }, []);\n  $dgwbL$useEffect(function () {\n    if (!isVirtualized && manager.focusedKey && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n      var element = scrollRef.current.querySelector(\"[data-key=\\\"\" + manager.focusedKey + \"\\\"]\");\n      if (element) $dgwbL$scrollIntoView(scrollRef.current, element);\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n  var handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown: function onMouseDown(e) {\n      if (e.currentTarget.contains(e.target)) e.preventDefault();\n    }\n  };\n\n  var _$a6f03d1cafa48b51$ex = $a6f03d1cafa48b51$export$e32c88dfddc6e1d8({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  }),\n      typeSelectProps = _$a6f03d1cafa48b51$ex.typeSelectProps;\n\n  if (!disallowTypeAhead) handlers = $dgwbL$mergeProps(typeSelectProps, handlers);\n  var tabIndex;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  return {\n    collectionProps: _objectSpread(_objectSpread({}, handlers), {}, {\n      tabIndex: tabIndex\n    })\n  };\n}\n\nvar $5ec5a493f6042709$exports = {};\n$parcel$export($5ec5a493f6042709$exports, \"useSelectableItem\", function () {\n  return $5ec5a493f6042709$export$ecf600387e221c37;\n});\n\nfunction $5ec5a493f6042709$export$ecf600387e221c37(options) {\n  var manager = options.selectionManager,\n      key = options.key,\n      ref = options.ref,\n      shouldSelectOnPressUp = options.shouldSelectOnPressUp,\n      isVirtualized = options.isVirtualized,\n      shouldUseVirtualFocus = options.shouldUseVirtualFocus,\n      focus = options.focus,\n      isDisabled = options.isDisabled,\n      onAction = options.onAction;\n\n  var onSelect = function onSelect(e) {\n    if (e.pointerType === 'keyboard' && $c636d3b6065ca9f6$export$d3e3bd3e26688c04(e)) manager.toggleSelection(key);else {\n      if (manager.selectionMode === 'none') return;\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) manager.toggleSelection(key);else manager.replaceSelection(key);\n      } else if (e && e.shiftKey) manager.extendSelection(key);else if (manager.selectionBehavior === 'toggle' || e && ($c636d3b6065ca9f6$export$16792effe837dba3(e) || e.pointerType === 'touch' || e.pointerType === 'virtual')) manager.toggleSelection(key);else manager.replaceSelection(key);\n    }\n  };\n\n  var isFocused = key === manager.focusedKey;\n  $dgwbL$useEffect(function () {\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) focus();else $dgwbL$focusSafely(ref.current);\n    }\n  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n  var itemProps = {};\n  if (!shouldUseVirtualFocus) itemProps = {\n    tabIndex: isFocused ? 0 : -1,\n    onFocus: function onFocus(e) {\n      if (e.target === ref.current) manager.setFocusedKey(key);\n    }\n  };\n  var modality = $dgwbL$useRef(null);\n  var hasPrimaryAction = onAction && manager.selectionMode === 'none';\n  var hasSecondaryAction = onAction && manager.selectionMode !== 'none' && manager.selectionBehavior === 'replace';\n  var allowsSelection = !isDisabled && manager.canSelectItem(key);\n  var itemPressProps = {};\n\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = function (e) {\n      modality.current = e.pointerType;\n      if (e.pointerType === 'keyboard') onSelect(e);\n    };\n\n    itemPressProps.onPressUp = function (e) {\n      if (e.pointerType !== 'keyboard') onSelect(e);\n    };\n\n    itemPressProps.onPress = hasPrimaryAction ? function () {\n      return onAction();\n    } : null;\n  } else {\n    itemPressProps.onPressStart = function (e) {\n      modality.current = e.pointerType;\n      if (e.pointerType !== 'touch' && e.pointerType !== 'virtual') onSelect(e);\n    };\n\n    itemPressProps.onPress = function (e) {\n      if (e.pointerType === 'touch' || e.pointerType === 'virtual' || hasPrimaryAction) {\n        if (hasPrimaryAction || hasSecondaryAction) onAction();else onSelect(e);\n      }\n    };\n  }\n\n  if (!isVirtualized) itemProps['data-key'] = key;\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n\n  var _$dgwbL$usePress = $dgwbL$usePress(itemPressProps),\n      pressProps = _$dgwbL$usePress.pressProps,\n      isPressed = _$dgwbL$usePress.isPressed;\n\n  var onDoubleClick = hasSecondaryAction ? function (e) {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n\n  var _$dgwbL$useLongPress = $dgwbL$useLongPress({\n    isDisabled: !hasSecondaryAction,\n    onLongPress: function onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  }),\n      longPressProps = _$dgwbL$useLongPress.longPressProps;\n\n  var onKeyUp = hasSecondaryAction ? function (e) {\n    if (e.key === 'Enter') onAction();\n  } : undefined;\n  return {\n    itemProps: $dgwbL$mergeProps(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, hasSecondaryAction ? longPressProps : {}, {\n      onKeyUp: onKeyUp,\n      onDoubleClick: onDoubleClick\n    }),\n    isPressed: isPressed\n  };\n}\n\nvar $38e0ab555fbd8768$exports = {};\n$parcel$export($38e0ab555fbd8768$exports, \"useSelectableList\", function () {\n  return $38e0ab555fbd8768$export$b95089534ab7c1fd;\n});\nvar $8dd8d9b0d53d6ca8$exports = {};\n$parcel$export($8dd8d9b0d53d6ca8$exports, \"ListKeyboardDelegate\", function () {\n  return $8dd8d9b0d53d6ca8$export$a05409b8bb224a5a;\n});\n\nvar $8dd8d9b0d53d6ca8$export$a05409b8bb224a5a = function () {\n  function $8dd8d9b0d53d6ca8$export$a05409b8bb224a5a(collection, disabledKeys, ref, collator) {\n    _classCallCheck(this, $8dd8d9b0d53d6ca8$export$a05409b8bb224a5a);\n\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  _createClass($8dd8d9b0d53d6ca8$export$a05409b8bb224a5a, [{\n    key: \"getKeyBelow\",\n    value: function getKeyBelow(key) {\n      key = this.collection.getKeyAfter(key);\n\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyAfter(key);\n      }\n    }\n  }, {\n    key: \"getKeyAbove\",\n    value: function getKeyAbove(key) {\n      key = this.collection.getKeyBefore(key);\n\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyBefore(key);\n      }\n    }\n  }, {\n    key: \"getFirstKey\",\n    value: function getFirstKey() {\n      var key = this.collection.getFirstKey();\n\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyAfter(key);\n      }\n    }\n  }, {\n    key: \"getLastKey\",\n    value: function getLastKey() {\n      var key = this.collection.getLastKey();\n\n      while (key != null) {\n        var item = this.collection.getItem(key);\n        if (item.type === 'item' && !this.disabledKeys.has(key)) return key;\n        key = this.collection.getKeyBefore(key);\n      }\n    }\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this.ref.current.querySelector(\"[data-key=\\\"\" + key + \"\\\"]\");\n    }\n  }, {\n    key: \"getKeyPageAbove\",\n    value: function getKeyPageAbove(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n      if (!item) return null;\n      var pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n      while (item && item.offsetTop > pageY) {\n        key = this.getKeyAbove(key);\n        item = this.getItem(key);\n      }\n\n      return key;\n    }\n  }, {\n    key: \"getKeyPageBelow\",\n    value: function getKeyPageBelow(key) {\n      var menu = this.ref.current;\n      var item = this.getItem(key);\n      if (!item) return null;\n      var pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n      while (item && item.offsetTop < pageY) {\n        key = this.getKeyBelow(key);\n        item = this.getItem(key);\n      }\n\n      return key;\n    }\n  }, {\n    key: \"getKeyForSearch\",\n    value: function getKeyForSearch(search, fromKey) {\n      if (!this.collator) return null;\n      var collection = this.collection;\n      var key = fromKey || this.getFirstKey();\n\n      while (key != null) {\n        var item = collection.getItem(key);\n        var substring = item.textValue.slice(0, search.length);\n        if (item.textValue && this.collator.compare(substring, search) === 0) return key;\n        key = this.getKeyBelow(key);\n      }\n\n      return null;\n    }\n  }]);\n\n  return $8dd8d9b0d53d6ca8$export$a05409b8bb224a5a;\n}();\n\nfunction $38e0ab555fbd8768$export$b95089534ab7c1fd(props) {\n  var selectionManager = props.selectionManager,\n      collection = props.collection,\n      disabledKeys = props.disabledKeys,\n      ref = props.ref,\n      keyboardDelegate = props.keyboardDelegate,\n      autoFocus = props.autoFocus,\n      shouldFocusWrap = props.shouldFocusWrap,\n      isVirtualized = props.isVirtualized,\n      disallowEmptySelection = props.disallowEmptySelection,\n      _props$selectOnFocus = props.selectOnFocus,\n      selectOnFocus = _props$selectOnFocus === void 0 ? false : _props$selectOnFocus,\n      disallowTypeAhead = props.disallowTypeAhead,\n      shouldUseVirtualFocus = props.shouldUseVirtualFocus,\n      allowsTabNavigation = props.allowsTabNavigation;\n  var collator = $dgwbL$useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  var delegate = $dgwbL$useMemo(function () {\n    return keyboardDelegate || new $8dd8d9b0d53d6ca8$export$a05409b8bb224a5a(collection, disabledKeys, ref, collator);\n  }, [keyboardDelegate, collection, disabledKeys, ref, collator]);\n\n  var _$52ac987c016884e9$ex = $52ac987c016884e9$export$d6daf82dcd84e87c({\n    ref: ref,\n    selectionManager: selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus: autoFocus,\n    shouldFocusWrap: shouldFocusWrap,\n    disallowEmptySelection: disallowEmptySelection,\n    selectOnFocus: selectOnFocus,\n    disallowTypeAhead: disallowTypeAhead,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation: allowsTabNavigation,\n    isVirtualized: isVirtualized,\n    scrollRef: ref\n  }),\n      collectionProps = _$52ac987c016884e9$ex.collectionProps;\n\n  return {\n    listProps: collectionProps\n  };\n}\n\nexport { $52ac987c016884e9$export$d6daf82dcd84e87c as useSelectableCollection, $5ec5a493f6042709$export$ecf600387e221c37 as useSelectableItem, $38e0ab555fbd8768$export$b95089534ab7c1fd as useSelectableList, $8dd8d9b0d53d6ca8$export$a05409b8bb224a5a as ListKeyboardDelegate, $a6f03d1cafa48b51$export$e32c88dfddc6e1d8 as useTypeSelect };","map":{"version":3,"sources":["packages/@react-aria/selection/src/useSelectableCollection.ts","packages/@react-aria/selection/src/utils.ts","packages/@react-aria/selection/src/useTypeSelect.ts","packages/@react-aria/selection/src/useSelectableItem.ts","packages/@react-aria/selection/src/useSelectableList.ts","packages/@react-aria/selection/src/ListKeyboardDelegate.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusEvent, HTMLAttributes, Key, KeyboardEvent, RefObject, useEffect, useRef} from 'react';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {FocusStrategy, KeyboardDelegate} from '@react-types/shared';\nimport {focusWithoutScrolling, mergeProps, scrollIntoView, useEvent} from '@react-aria/utils';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useLocale} from '@react-aria/i18n';\nimport {useTypeSelect} from './useTypeSelect';\n\ninterface SelectableCollectionOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A delegate object that implements behavior for keyboard focus movement.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * The ref attached to the element representing the collection.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether the collection allows the user to select all items via keyboard shortcut.\n   * @default false\n   */\n  disallowSelectAll?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean,\n  /**\n   * Whether the collection items are contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections.\n   * If not provided, defaults to the collection ref.\n   */\n  scrollRef?: RefObject<HTMLElement>\n}\n\ninterface SelectableCollectionAria {\n  /** Props for the collection element. */\n  collectionProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with selectable collections.\n */\nexport function useSelectableCollection(options: SelectableCollectionOptions): SelectableCollectionAria {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === 'replace',\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref\n  } = options;\n  let {direction} = useLocale();\n\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === 'Tab') {\n      e.preventDefault();\n    }\n\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target as HTMLElement)) {\n      return;\n    }\n\n    const navigateToKey = (key: Key | undefined, childFocus?: FocusStrategy) => {\n      if (key != null) {\n        manager.setFocusedKey(key, childFocus);\n\n        if (e.shiftKey && manager.selectionMode === 'multiple') {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n\n    switch (e.key) {\n      case 'ArrowDown': {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyBelow(manager.focusedKey)\n              : delegate.getFirstKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowUp': {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null\n              ? delegate.getKeyAbove(manager.focusedKey)\n              : delegate.getLastKey?.();\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(manager.focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case 'ArrowLeft': {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');\n        }\n        break;\n      }\n      case 'Home':\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(firstKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(firstKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(firstKey);\n          }\n        }\n        break;\n      case 'End':\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, isCtrlKeyPressed(e));\n          manager.setFocusedKey(lastKey);\n          if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {\n            manager.extendSelection(lastKey);\n          } else if (selectOnFocus) {\n            manager.replaceSelection(lastKey);\n          }\n        }\n        break;\n      case 'PageDown':\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'PageUp':\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case 'a':\n        if (isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        if (!disallowEmptySelection) {\n          manager.clearSelection();\n        }\n        break;\n      case 'Tab': {\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) {\n            ref.current.focus();\n          } else {\n            let walker = getFocusableTreeWalker(ref.current, {tabbable: true});\n            let next: HTMLElement;\n            let last: HTMLElement;\n            do {\n              last = walker.lastChild() as HTMLElement;\n              if (last) {\n                next = last;\n              }\n            } while (last);\n\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n\n  // Store the scroll position so we can restore it later.\n  let scrollPos = useRef({top: 0, left: 0});\n  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n\n  let onFocus = (e: FocusEvent) => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n\n      return;\n    }\n\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n\n    manager.setFocused(true);\n\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = (key: Key | undefined) => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) {\n            manager.replaceSelection(key);\n          }\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget as Element;\n      if (relatedTarget && (e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING)) {\n        navigateToFirstKey(manager.lastSelectedKey ?? delegate.getLastKey());\n      } else {\n        navigateToFirstKey(manager.firstSelectedKey ?? delegate.getFirstKey());\n      }\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection\n        focusWithoutScrolling(element);\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  };\n\n  let onBlur = (e) => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget as HTMLElement)) {\n      manager.setFocused(false);\n    }\n  };\n\n  const autoFocusRef = useRef(autoFocus);\n  useEffect(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === 'first') {\n        focusedKey = delegate.getFirstKey();\n      } if (autoFocus === 'last') {\n        focusedKey = delegate.getLastKey();\n      }\n\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        focusedKey = selectedKeys.values().next().value;\n      }\n\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) {\n        focusSafely(ref.current);\n      }\n    }\n    autoFocusRef.current = false;\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  useEffect(() => {\n    if (!isVirtualized && manager.focusedKey && scrollRef?.current) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${manager.focusedKey}\"]`) as HTMLElement;\n      if (element) {\n        scrollIntoView(scrollRef.current, element);\n      }\n    }\n  }, [isVirtualized, scrollRef, manager.focusedKey]);\n\n  let handlers = {\n    onKeyDown,\n    onFocus,\n    onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (e.currentTarget.contains(e.target)) {\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n\n  if (!disallowTypeAhead) {\n    handlers = mergeProps(typeSelectProps, handlers);\n  }\n\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex: number;\n  if (!shouldUseVirtualFocus) {\n    tabIndex = manager.focusedKey == null ? 0 : -1;\n  }\n\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {isAppleDevice} from '@react-aria/utils';\nimport {isMac} from '@react-aria/utils';\n\ninterface Event {\n  altKey: boolean,\n  ctrlKey: boolean,\n  metaKey: boolean\n}\n\nexport function isNonContiguousSelectionModifier(e: Event) {\n  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.\n  // On Windows and Ubuntu, Alt + Space has a system wide meaning.\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\n\nexport function isCtrlKeyPressed(e: Event) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n\n  return e.ctrlKey;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {HTMLAttributes, Key, KeyboardEvent, useRef} from 'react';\nimport {KeyboardDelegate} from '@react-types/shared';\nimport {MultipleSelectionManager} from '@react-stately/selection';\n\ninterface TypeSelectOptions {\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate: KeyboardDelegate,\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * Called when an item is focused by typing.\n   */\n  onTypeSelect?: (key: Key) => void\n}\n\ninterface TypeSelectAria {\n  /**\n   * Props to be spread on the owner of the options.\n   */\n  typeSelectProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles typeahead interactions with collections.\n */\nexport function useTypeSelect(options: TypeSelectOptions): TypeSelectAria {\n  let {keyboardDelegate, selectionManager, onTypeSelect} = options;\n  let state = useRef({\n    search: '',\n    timeout: null\n  }).current;\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    let character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n\n    // Do not propagate the Spacebar event if it's meant to be part of the search.\n    // When we time out, the search term becomes empty, hence the check on length.\n    // Trimming is to account for the case of pressing the Spacebar more than once,\n    // which should cycle through the selection/deselection of the focused item.\n    if (character === ' ' && state.search.trim().length > 0) {\n      e.preventDefault();\n      if (!('continuePropagation' in e)) {\n        e.stopPropagation();\n      }\n    }\n\n    state.search += character;\n\n    // Use the delegate to find a key to focus.\n    // Prioritize items after the currently focused item, falling back to searching the whole list.\n    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey);\n\n    // If no key found, search from the top.\n    if (key == null) {\n      key = keyboardDelegate.getKeyForSearch(state.search);\n    }\n\n    if (key != null) {\n      selectionManager.setFocusedKey(key);\n      if (onTypeSelect) {\n        onTypeSelect(key);\n      }\n    }\n\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(() => {\n      state.search = '';\n    }, 500);\n  };\n\n  return {\n    typeSelectProps: {\n      // Using a capturing listener to catch the keydown event before\n      // other hooks in order to handle the Spacebar event.\n      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null\n    }\n  };\n}\n\nfunction getStringForKey(key: string) {\n  // If the key is of length 1, it is an ASCII value.\n  // Otherwise, if there are no ASCII characters in the key name,\n  // it is a Unicode character.\n  // See https://www.w3.org/TR/uievents-key/\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n\n  return '';\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {focusSafely} from '@react-aria/focus';\nimport {HTMLAttributes, Key, RefObject, useEffect, useRef} from 'react';\nimport {isCtrlKeyPressed, isNonContiguousSelectionModifier} from './utils';\nimport {LongPressEvent, PressEvent} from '@react-types/shared';\nimport {mergeProps} from '@react-aria/utils';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {PressProps, useLongPress, usePress} from '@react-aria/interactions';\n\ninterface SelectableItemOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * A unique key for the item.\n   */\n  key: Key,\n  /**\n   * Ref to the item.\n   */\n  ref: RefObject<HTMLElement>,\n  /**\n   * By default, selection occurs on pointer down. This can be strange if selecting an\n   * item causes the UI to disappear immediately (e.g. menus).\n   */\n  shouldSelectOnPressUp?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Function to focus the item.\n   */\n  focus?: () => void,\n  /**\n   * Whether the option should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /** Whether the item is disabled. */\n  isDisabled?: boolean,\n  /**\n   * Handler that is called when a user performs an action on the cell. The exact user event depends on\n   * the collection's `selectionBehavior` prop and the interaction modality.\n   */\n  onAction?: () => void\n}\n\ninterface SelectableItemAria {\n  /**\n   * Props to be spread on the item root node.\n   */\n  itemProps: HTMLAttributes<HTMLElement>,\n  /** Whether the item is currently in a pressed state. */\n  isPressed: boolean\n}\n\n/**\n * Handles interactions with an item in a selectable collection.\n */\nexport function useSelectableItem(options: SelectableItemOptions): SelectableItemAria {\n  let {\n    selectionManager: manager,\n    key,\n    ref,\n    shouldSelectOnPressUp,\n    isVirtualized,\n    shouldUseVirtualFocus,\n    focus,\n    isDisabled,\n    onAction\n  } = options;\n\n  let onSelect = (e: PressEvent | LongPressEvent | PointerEvent) => {\n    if (e.pointerType === 'keyboard' && isNonContiguousSelectionModifier(e)) {\n      manager.toggleSelection(key);\n    } else {\n      if (manager.selectionMode === 'none') {\n        return;\n      }\n\n      if (manager.selectionMode === 'single') {\n        if (manager.isSelected(key) && !manager.disallowEmptySelection) {\n          manager.toggleSelection(key);\n        } else {\n          manager.replaceSelection(key);\n        }\n      } else if (e && e.shiftKey) {\n        manager.extendSelection(key);\n      } else if (manager.selectionBehavior === 'toggle' || (e && (isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual'))) {\n        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys\n        manager.toggleSelection(key);\n      } else {\n        manager.replaceSelection(key);\n      }\n    }\n  };\n\n  // Focus the associated DOM node when this item becomes the focusedKey\n  let isFocused = key === manager.focusedKey;\n  useEffect(() => {\n    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {\n      if (focus) {\n        focus();\n      } else {\n        focusSafely(ref.current);\n      }\n    }\n  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]);\n\n  // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused\n  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver\n  // on iOS 14 doesn't try to move real DOM focus to the item anyway.\n  let itemProps: SelectableItemAria['itemProps'] = {};\n  if (!shouldUseVirtualFocus) {\n    itemProps = {\n      tabIndex: isFocused ? 0 : -1,\n      onFocus(e) {\n        if (e.target === ref.current) {\n          manager.setFocusedKey(key);\n        }\n      }\n    };\n  }\n\n  let modality = useRef(null);\n  let hasPrimaryAction = onAction && manager.selectionMode === 'none';\n  let hasSecondaryAction = onAction && manager.selectionMode !== 'none' && manager.selectionBehavior === 'replace';\n  let allowsSelection = !isDisabled && manager.canSelectItem(key);\n\n  // By default, selection occurs on pointer down. This can be strange if selecting an\n  // item causes the UI to disappear immediately (e.g. menus).\n  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.\n  // onPress requires a pointer down event on the same element as pointer up. For menus,\n  // we want to be able to have the pointer down on the trigger that opens the menu and\n  // the pointer up on the menu item rather than requiring a separate press.\n  // For keyboard events, selection still occurs on key down.\n  let itemPressProps: PressProps = {};\n  if (shouldSelectOnPressUp) {\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      if (e.pointerType === 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPressUp = (e) => {\n      if (e.pointerType !== 'keyboard') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;\n  } else {\n    // On touch, it feels strange to select on touch down, so we special case this.\n    itemPressProps.onPressStart = (e) => {\n      modality.current = e.pointerType;\n      if (e.pointerType !== 'touch' && e.pointerType !== 'virtual') {\n        onSelect(e);\n      }\n    };\n\n    itemPressProps.onPress = (e) => {\n      if (e.pointerType === 'touch' || e.pointerType === 'virtual' || hasPrimaryAction) {\n        // Single tap on touch with selectionBehavior = 'replace' performs an action, i.e. navigation.\n        // Also perform action on press up when selectionMode = 'none'.\n        if (hasPrimaryAction || hasSecondaryAction) {\n          onAction();\n        } else {\n          onSelect(e);\n        }\n      }\n    };\n  }\n\n  if (!isVirtualized) {\n    itemProps['data-key'] = key;\n  }\n\n  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;\n  let {pressProps, isPressed} = usePress(itemPressProps);\n\n  // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.\n  let onDoubleClick = hasSecondaryAction ? (e) => {\n    if (modality.current === 'mouse') {\n      e.stopPropagation();\n      e.preventDefault();\n      onAction();\n    }\n  } : undefined;\n\n  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior\n  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to\n  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.\n  // TODO: what about when drag and drop is also enabled??\n  let {longPressProps} = useLongPress({\n    isDisabled: !hasSecondaryAction,\n    onLongPress(e) {\n      if (e.pointerType === 'touch') {\n        onSelect(e);\n        manager.setSelectionBehavior('toggle');\n      }\n    }\n  });\n\n  // Pressing the Enter key with selectionBehavior = 'replace' performs an action (i.e. navigation).\n  let onKeyUp = hasSecondaryAction ? (e: KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      onAction();\n    }\n  } : undefined;\n\n  return {\n    itemProps: mergeProps(\n      itemProps,\n      allowsSelection || hasPrimaryAction ? pressProps : {},\n      hasSecondaryAction ? longPressProps : {},\n      {onKeyUp, onDoubleClick}\n    ),\n    isPressed\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, FocusStrategy, KeyboardDelegate, Node} from '@react-types/shared';\nimport {HTMLAttributes, Key, RefObject, useMemo} from 'react';\nimport {ListKeyboardDelegate} from './ListKeyboardDelegate';\nimport {MultipleSelectionManager} from '@react-stately/selection';\nimport {useCollator} from '@react-aria/i18n';\nimport {useSelectableCollection} from './useSelectableCollection';\n\ninterface SelectableListOptions {\n  /**\n   * An interface for reading and updating multiple selection state.\n   */\n  selectionManager: MultipleSelectionManager,\n  /**\n   * State of the collection.\n   */\n  collection: Collection<Node<unknown>>,\n  /**\n   * The item keys that are disabled. These items cannot be selected, focused, or otherwise interacted with.\n   */\n  disabledKeys: Set<Key>,\n  /**\n   * A ref to the item.\n   */\n  ref?: RefObject<HTMLElement>,\n  /**\n   * A delegate that returns collection item keys with respect to visual layout.\n   */\n  keyboardDelegate?: KeyboardDelegate,\n  /**\n   * Whether the collection or one of its items should be automatically focused upon render.\n   * @default false\n   */\n  autoFocus?: boolean | FocusStrategy,\n  /**\n   * Whether focus should wrap around when the end/start is reached.\n   * @default false\n   */\n  shouldFocusWrap?: boolean,\n  /**\n   * Whether the option is contained in a virtual scroller.\n   */\n  isVirtualized?: boolean,\n  /**\n   * Whether the collection allows empty selection.\n   * @default false\n   */\n  disallowEmptySelection?: boolean,\n  /**\n   * Whether selection should occur automatically on focus.\n   * @default false\n   */\n  selectOnFocus?: boolean,\n  /**\n   * Whether typeahead is disabled.\n   * @default false\n   */\n  disallowTypeAhead?: boolean,\n  /**\n   * Whether the collection items should use virtual focus instead of being focused directly.\n   */\n  shouldUseVirtualFocus?: boolean,\n  /**\n   * Whether navigation through tab key is enabled.\n   */\n  allowsTabNavigation?: boolean\n}\n\ninterface SelectableListAria {\n  /**\n   * Props for the option element.\n   */\n  listProps: HTMLAttributes<HTMLElement>\n}\n\n/**\n * Handles interactions with a selectable list.\n */\nexport function useSelectableList(props: SelectableListOptions): SelectableListAria {\n  let {\n    selectionManager,\n    collection,\n    disabledKeys,\n    ref,\n    keyboardDelegate,\n    autoFocus,\n    shouldFocusWrap,\n    isVirtualized,\n    disallowEmptySelection,\n    selectOnFocus = false,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]);\n\n  let {collectionProps} = useSelectableCollection({\n    ref,\n    selectionManager,\n    keyboardDelegate: delegate,\n    autoFocus,\n    shouldFocusWrap,\n    disallowEmptySelection,\n    selectOnFocus,\n    disallowTypeAhead,\n    shouldUseVirtualFocus,\n    allowsTabNavigation,\n    isVirtualized,\n    scrollRef: ref\n  });\n\n  return {\n    listProps: collectionProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection, KeyboardDelegate, Node} from '@react-types/shared';\nimport {Key, RefObject} from 'react';\n\nexport class ListKeyboardDelegate<T> implements KeyboardDelegate {\n  private collection: Collection<Node<T>>;\n  private disabledKeys: Set<Key>;\n  private ref: RefObject<HTMLElement>;\n  private collator: Intl.Collator;\n\n  constructor(collection: Collection<Node<T>>, disabledKeys: Set<Key>, ref: RefObject<HTMLElement>, collator?: Intl.Collator) {\n    this.collection = collection;\n    this.disabledKeys = disabledKeys;\n    this.ref = ref;\n    this.collator = collator;\n  }\n\n  getKeyBelow(key: Key) {\n    key = this.collection.getKeyAfter(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getKeyAbove(key: Key) {\n    key = this.collection.getKeyBefore(key);\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  getFirstKey() {\n    let key = this.collection.getFirstKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyAfter(key);\n    }\n  }\n\n  getLastKey() {\n    let key = this.collection.getLastKey();\n    while (key != null) {\n      let item = this.collection.getItem(key);\n      if (item.type === 'item' && !this.disabledKeys.has(key)) {\n        return key;\n      }\n\n      key = this.collection.getKeyBefore(key);\n    }\n  }\n\n  private getItem(key: Key): HTMLElement {\n    return this.ref.current.querySelector(`[data-key=\"${key}\"]`);\n  }\n\n  getKeyPageAbove(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);\n\n    while (item && item.offsetTop > pageY) {\n      key = this.getKeyAbove(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyPageBelow(key: Key) {\n    let menu = this.ref.current;\n    let item = this.getItem(key);\n    if (!item) {\n      return null;\n    }\n\n    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);\n\n    while (item && item.offsetTop < pageY) {\n      key = this.getKeyBelow(key);\n      item = this.getItem(key);\n    }\n\n    return key;\n  }\n\n  getKeyForSearch(search: string, fromKey?: Key) {\n    if (!this.collator) {\n      return null;\n    }\n\n    let collection = this.collection;\n    let key = fromKey || this.getFirstKey();\n    while (key != null) {\n      let item = collection.getItem(key);\n      let substring = item.textValue.slice(0, search.length);\n      if (item.textValue && this.collator.compare(substring, search) === 0) {\n        return key;\n      }\n\n      key = this.getKeyBelow(key);\n    }\n\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}